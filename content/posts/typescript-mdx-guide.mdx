---
title: TypeScript Generics
description: A comprehensive guide to understanding and implementing powerful generic types in TypeScript
date: 2024-03-20
---

# Demystifying TypeScript Generics

Generics are one of the most powerful features in TypeScript, allowing you to create reusable, type-safe components. Let's dive deep into how they work and why they're essential for writing flexible code.

## What Are Generics?

Generics enable you to create components that can work over a variety of types rather than a single one. Think of them as type-level functions that help you write more dynamic and reusable code.

## Basic Generic Function

```typescript
function identity<T>(arg: T): T {
  return arg;
}

// Usage
let stringResult = identity<string>("Hello, Generics!");
let numberResult = identity<number>(42);
```

## Generic Interfaces

Create flexible interfaces that can work with multiple types:

```typescript
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

// Different type combinations
const stringNumberPair: KeyValuePair<string, number> = {
  key: "age",
  value: 30
};

const booleanObjectPair: KeyValuePair<boolean, { name: string }> = {
  key: true,
  value: { name: "Dynamic Object" }
};
```

## Advanced Generic Constraints

Limit the types that can be used with generics:

```typescript
// Ensure the type has a length property
function getLength<T extends { length: number }>(arg: T): number {
  return arg.length;
}

// Works with arrays, strings
console.log(getLength([1, 2, 3])); // 3
console.log(getLength("typescript")); // 10

// Doesn't work with numbers
// getLength(42); // Compile-time error
```

## Real-World Generic Pattern: Repository Class

```typescript
class Repository<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }

  find(predicate: (item: T) => boolean): T | undefined {
    return this.items.find(predicate);
  }
}

// User repository
interface User {
  id: number;
  name: string;
  email: string;
}

const userRepository = new Repository<User>();
userRepository.add({
  id: 1,
  name: "Alice",
  email: "alice@example.com"
});
```

## Conditional Types: Taking Generics Further

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;

// Removes null and undefined from the type
type SafeString = NonNullable<string | null | undefined>;
// Result is just 'string'
```

## Common Gotchas

1. **Performance**: Generics don't add runtime overhead
2. **Type Inference**: TypeScript can often infer types automatically
3. **Readability**: Don't overuse generics â€“ keep it simple!

## When to Use Generics

- Creating reusable utility functions
- Building type-safe data structures
- Writing flexible class implementations
- Creating abstract algorithms that work with multiple types

## Pro Tip: Combining Generics with Utility Types

```typescript
type Nullable<T> = { [P in keyof T]: T[P] | null };

interface Person {
  name: string;
  age: number;
}

// All fields become optional and nullable
type NullablePerson = Nullable<Person>;
```

## Conclusion

Generics are more than just a TypeScript feature â€“ they're a powerful way to write flexible, type-safe code. Start simple, and gradually explore more advanced patterns.

Happy typing! ðŸš€
